--method that rank-orders houses given a parameter
-one could begin with the output, from large to small
-this way wijk 3 would be connected

--hill-climber algorithm:
-use the option used in a as a standard-configuration to compare
-then try different improvements and compare these with the original solution
-try to swap houses and then see what happens

--class configuration:
-make a class configuration that holds all the cables (should be enough)
-built in function to calculate costs given the cables
-built in function to "wire" area
-built in function to save configuration to txt file for later comparison

--Things to fix:
-Check cost function
-->if not all houses are connected, is cost added to total costs?

--Comparison-points:
-"Random" solution from a as worst case x 1000 for tight upper bound
-->Better greedy upper bound (and greedy lower bound with shortest distance)
-"Illegal" solution with closest batteries as best case (not achievable)
-->Benchmark


----------------------------Lecture 2
--Ideas for algorithms:
-Bidirectional search
-depth first
-->implement in hill climber
-Branch 'n' Bound!!!

--Presentation:
-Animate best paths

--Archive
-Fast lookup time
-->hash table

--Traveling salesman
-Allegory for our case
-->Branch and bound!!
-Maybe depth first (costs a lot of time)
-->Account supercomputer!

--Branch and bound
-Use benchmark to prune
-recursive
-->Slide branch 'n' bound
--->Find the best solution guaranteed

----------------------------Lecture 3
Iterative and constructive
--hill-climber
-Search for improvement
-But: sometimes dis-improvement leads to greater improvement
-->Simulated annealing
